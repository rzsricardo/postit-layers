<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Post-it Layers (PWA)</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#111827">
  <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAyNTYgMjU2Jz4KPHJlY3Qgd2lkdGg9JzI1NicgaGVpZ2h0PScyNTYnIHJ4PSc0OCcgZmlsbD0nIzExMTgyNycvPgo8cmVjdCB4PSczNicgeT0nMzYnIHdpZHRoPScxODQnIGhlaWdodD0nMTg0JyByeD0nMjAnIGZpbGw9JyNmZGU2OGEnLz4KPC9zdmc+">
  <style>
    html, body, #root { height: 100%; margin: 0; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, 'Helvetica Neue', Arial; background: linear-gradient(#fafafa, #efefef); color: #111827; }
    .shadow { box-shadow: 0 10px 30px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.08); }
    .rounded-2xl { border-radius: 1rem; }
    .rounded-xl { border-radius: .75rem; }
    .border { border: 1px solid rgba(0,0,0,.12); }
    .btn { padding: .375rem .75rem; border: 1px solid rgba(0,0,0,.12); border-radius: .75rem; background: #fff8; backdrop-filter: blur(8px); cursor: pointer; }
    .btn:hover { background: #fff; }
    .panel { background: #fffE; backdrop-filter: blur(8px); }
    .gridbg { background-size: 32px 32px; background-image:
      linear-gradient(to right, rgba(0,0,0,0.04) 1px, transparent 1px),
      linear-gradient(to bottom, rgba(0,0,0,0.04) 1px, transparent 1px);
    }
    textarea { font: inherit; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    function uid(prefix = "id") { return prefix + "_" + Math.random().toString(36).slice(2,9); }

    const DEFAULT_NOTE_SIZE = { w: 180, h: 140 };
    const STORAGE_KEY = "postit_layers_app_v01";
    const COLORS = ["#fde68a","#a7f3d0","#bfdbfe","#fecaca","#ddd6fe","#e9d5ff","#fbcfe8"];

    function loadInitial() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) return JSON.parse(raw);
      } catch (e) {}
      const layerA = { id: uid("layer"), name: "Strategy", visible: true };
      const layerB = { id: uid("layer"), name: "Tasks", visible: true };
      const layerC = { id: uid("layer"), name: "Inspiration", visible: false };

      const n1 = { id: uid("note"), ownerLayerId: layerA.id, x: 100, y: 80,
        text: "Project overview\n— audience\n— value prop",
        color: COLORS[0], w: DEFAULT_NOTE_SIZE.w, h: DEFAULT_NOTE_SIZE.h,
        styleOverrides: (function(){ var o={}; o[layerB.id]={ visible: true, color: COLORS[2], opacity: .9 }; return o; })() };
      const n2 = { id: uid("note"), ownerLayerId: layerB.id, x: 420, y: 220,
        text: "MVP backlog\n- Canvas\n- Layers\n- LocalStorage",
        color: COLORS[1], w: DEFAULT_NOTE_SIZE.w, h: DEFAULT_NOTE_SIZE.h,
        styleOverrides: {} };
      const n3 = { id: uid("note"), ownerLayerId: layerA.id, x: 700, y: 120,
        text: "Risks\n- Scope\n- Schedule\n- Tech debt",
        color: COLORS[3], w: DEFAULT_NOTE_SIZE.w, h: DEFAULT_NOTE_SIZE.h,
        styleOverrides: (function(){ var o={}; o[layerC.id]={ visible: true, opacity: .6 }; return o; })() };

      return { layers: [layerA, layerB, layerC], notes: [n1, n2, n3], activeLayerId: layerA.id };
    }

    function App() {
      const [state, setState] = useState(loadInitial);
      const { layers, notes, activeLayerId } = state;

      useEffect(() => {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (e) {}
      }, [state]);

      const activeLayer = useMemo(() => layers.find(l => l.id === activeLayerId) || layers[0], [layers, activeLayerId]);

      const canvasRef = useRef(null);
      const [camera, setCamera] = useState({ x: 0, y: 0, scale: 1 });
      const isPanningRef = useRef(false);
      const lastPosRef = useRef({ x: 0, y: 0 });

      const worldToScreen = (x, y) => ({ x: (x + camera.x) * camera.scale, y: (y + camera.y) * camera.scale });
      const screenToWorld = (sx, sy) => ({ x: sx / camera.scale - camera.x, y: sy / camera.scale - camera.y });

      const onWheel = (e) => {
        e.preventDefault();
        const rect = canvasRef.current.getBoundingClientRect();
        const mouse = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        const delta = -Math.sign(e.deltaY) * 0.1;
        const newScale = Math.min(3, Math.max(.25, camera.scale * (1 + delta)));
        setCamera(c => ({ ...c, scale: newScale }));
      };

      const onBackgroundMouseDown = (e) => {
        if (e.button !== 0) return;
        isPanningRef.current = true;
        lastPosRef.current = { x: e.clientX, y: e.clientY };
      };
      const onMouseMove = (e) => {
        if (!isPanningRef.current) return;
        const dx = (e.clientX - lastPosRef.current.x) / camera.scale;
        const dy = (e.clientY - lastPosRef.current.y) / camera.scale;
        lastPosRef.current = { x: e.clientX, y: e.clientY };
        setCamera(c => ({ ...c, x: c.x + dx, y: c.y + dy }));
      };
      const onMouseUp = () => (isPanningRef.current = false);

      useEffect(() => {
        const el = canvasRef.current;
        el.addEventListener("wheel", onWheel, { passive: false });
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("mousemove", onMouseMove);
        return () => {
          el.removeEventListener("wheel", onWheel);
          window.removeEventListener("mouseup", onMouseUp);
          window.removeEventListener("mousemove", onMouseMove);
        };
      });

      const setLayers = (fn) => setState(s => ({ ...s, layers: fn(s.layers) }));
      const setNotes = (fn) => setState(s => ({ ...s, notes: fn(s.notes) }));

      const visibleLayerIds = useMemo(() => new Set(layers.filter(l => l.visible).map(l => l.id)), [layers]);

      function getOverride(note, lid) {
        return (note.styleOverrides && note.styleOverrides[lid]) ? note.styleOverrides[lid] : null;
      }

      function noteEffectiveStyle(note) {
        const a = getOverride(note, activeLayerId);
        if (a && a.visible) return { color: (a.color ? a.color : note.color), opacity: (a.opacity != null ? a.opacity : 1) };
        if (visibleLayerIds.has(note.ownerLayerId)) return { color: note.color, opacity: 1 };
        var keys = Object.keys(note.styleOverrides || {});
        for (var i=0;i<keys.length;i++) {
          var lid = keys[i];
          var o = note.styleOverrides[lid];
          if (visibleLayerIds.has(lid) && o.visible) return { color: (o.color ? o.color : note.color), opacity: (o.opacity != null ? o.opacity : 1) };
        }
        return null;
      }

      const [draggingId, setDraggingId] = useState(null);

      function startDragNote(note, e) {
        e.stopPropagation();
        setDraggingId(note.id);
        const start = { x: e.clientX, y: e.clientY };
        const startPos = { x: note.x, y: note.y };
        const move = (ev) => {
          if (draggingId !== note.id) return;
          const dx = (ev.clientX - start.x) / camera.scale;
          const dy = (ev.clientY - start.y) / camera.scale;
          setNotes(arr => arr.map(n => n.id === note.id ? { ...n, x: startPos.x + dx, y: startPos.y + dy } : n));
        };
        const up = () => {
          setDraggingId(null);
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
        };
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);
      }

      function createNote() {
        if (!activeLayer) return;
        const newNote = {
          id: uid("note"),
          ownerLayerId: activeLayer.id,
          x: -camera.x + 100 / camera.scale,
          y: -camera.y + 100 / camera.scale,
          text: "New note",
          color: COLORS[Math.floor(Math.random() * COLORS.length)],
          w: DEFAULT_NOTE_SIZE.w, h: DEFAULT_NOTE_SIZE.h,
          styleOverrides: {}
        };
        setNotes(arr => [...arr, newNote]);
      }

      function duplicateNote(note) {
        const copy = { ...note, id: uid("note"), x: note.x + 24, y: note.y + 24 };
        setNotes(arr => [...arr, copy]);
      }

      function deleteNote(note) {
        setNotes(arr => arr.filter(n => n.id !== note.id));
      }

      function resizeNote(note, e) {
        e.stopPropagation();
        const start = { x: e.clientX, y: e.clientY };
        const startSize = { w: note.w, h: note.h };
        const move = (ev) => {
          const dx = (ev.clientX - start.x) / camera.scale;
          const dy = (ev.clientY - start.y) / camera.scale;
          setNotes(arr => arr.map(n => n.id === note.id ? { ...n, w: Math.max(120, startSize.w + dx), h: Math.max(100, startSize.h + dy) } : n));
        };
        const up = () => {
          window.removeEventListener("mousemove", move);
          window.removeEventListener("mouseup", up);
        };
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);
      }

      function setActiveLayer(id) { setState(s => ({ ...s, activeLayerId: id })); }
      function toggleLayerVisibility(id) { setLayers(arr => arr.map(l => l.id === id ? { ...l, visible: !l.visible } : l)); }
      function addLayer() {
        const name = prompt("Layer name:") || "";
        const trimmed = name.trim();
        if (!trimmed) return;
        const layer = { id: uid("layer"), name: trimmed, visible: true };
        setLayers(arr => [...arr, layer]);
        setActiveLayer(layer.id);
      }
      function renameLayer(layer) {
        const name = prompt("New name:", layer.name) || "";
        const trimmed = name.trim();
        if (!trimmed) return;
        setLayers(arr => arr.map(l => l.id === layer.id ? { ...l, name: trimmed } : l));
      }
      function deleteLayer(layer) {
        const hasOwned = notes.some(n => n.ownerLayerId === layer.id);
        if (hasOwned) { alert("Cannot delete: layer owns notes."); return; }
        if (!confirm('Delete layer "' + layer.name + '"?')) return;
        setLayers(arr => arr.filter(l => l.id !== layer.id));
        setNotes(arr => arr.map(n => {
          const copy = { ...n };
          if (copy.styleOverrides && copy.styleOverrides[layer.id]) {
            const o = { ...copy.styleOverrides }; delete o[layer.id]; copy.styleOverrides = o;
          }
          return copy;
        }));
        if (activeLayerId === layer.id && layers.length) setActiveLayer(layers[0].id);
      }
      function referenceInActiveLayer(note) {
        if (!activeLayer) return;
        if (note.ownerLayerId === activeLayer.id) { alert("This note already belongs to the active layer."); return; }
        setNotes(arr => arr.map(n => n.id === note.id ? (function() {
          var ov = (n.styleOverrides ? { ...n.styleOverrides } : {});
          var cur = ov[activeLayer.id] ? { ...ov[activeLayer.id] } : {};
          cur.visible = true;
          ov[activeLayer.id] = cur;
          return { ...n, styleOverrides: ov };
        })() : n));
      }
      function setColor(note, color) {
        if (activeLayer && note.ownerLayerId === activeLayer.id) {
          setNotes(arr => arr.map(n => n.id === note.id ? { ...n, color } : n));
        } else if (activeLayer) {
          setNotes(arr => arr.map(n => n.id === note.id ? (function() {
            var ov = (n.styleOverrides ? { ...n.styleOverrides } : {});
            var cur = ov[activeLayer.id] ? { ...ov[activeLayer.id] } : {};
            cur.visible = true; cur.color = color;
            ov[activeLayer.id] = cur;
            return { ...n, styleOverrides: ov };
          })() : n));
        }
      }
      function toggleReferenceVisibility(note) {
        if (!activeLayer) return;
        setNotes(arr => arr.map(n => {
          if (n.id !== note.id) return n;
          var ov = (n.styleOverrides && n.styleOverrides[activeLayer.id]) ? { ...n.styleOverrides[activeLayer.id] } : {};
          ov.visible = !ov.visible;
          var all = (n.styleOverrides ? { ...n.styleOverrides } : {});
          all[activeLayer.id] = ov;
          return { ...n, styleOverrides: all };
        }));
      }

      function NoteCard({ note }) {
        const style = noteEffectiveStyle(note);
        if (!style) return null;
        const screen = worldToScreen(note.x, note.y);
        return (
          <div className="absolute shadow rounded-xl border"
            style={{
              position: 'absolute', left: screen.x, top: screen.y,
              width: note.w * camera.scale, height: note.h * camera.scale,
              transform: 'translate(-50%, -50%)', background: style.color,
              opacity: (style.opacity != null ? style.opacity : 1), cursor: 'grab'
            }}
            onMouseDown={(e) => startDragNote(note, e)}
          >
            <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', padding: '6px 10px', fontSize: 13, fontWeight: 600 }}>
              <span>{note.ownerLayerId === activeLayerId ? "(owner) " : ""}Post-it</span>
              <div style={{ display:'flex', gap: 6 }}>
                <button className="btn" onClick={(e)=>{e.stopPropagation(); duplicateNote(note);}} title="Duplicate">⧉</button>
                <button className="btn" onClick={(e)=>{e.stopPropagation(); referenceInActiveLayer(note);}} title="Reference">@</button>
                <button className="btn" onClick={(e)=>{e.stopPropagation(); deleteNote(note);}} title="Delete">✕</button>
              </div>
            </div>
            <textarea
              style={{ width:'100%', height: 'calc(100% - 48px)', padding: 10, border: 'none', outline: 'none', background: 'transparent', fontSize: 14 }}
              value={note.text}
              onChange={(e)=> setNotes(arr => arr.map(n => n.id === note.id ? { ...n, text: e.target.value } : n))}
              onMouseDown={(e)=> e.stopPropagation()}
            />
            <div title="Resize" style={{ position:'absolute', bottom: 6, right: 6, width: 16, height: 16, background: '#fff8', border: '1px solid rgba(0,0,0,.2)', borderRadius: 4, cursor:'nwse-resize' }}
              onMouseDown={(e)=> resizeNote(note, e)}
            />
          </div>
        );
      }

      function Toolbar() {
        return (
          <div className="shadow rounded-2xl panel" style={{ position:'fixed', top: 12, left: 12, zIndex: 50, display:'flex', alignItems:'center', gap: 8, padding: 8 }}>
            <button className="btn" onClick={createNote}>+ Post-it</button>
            <div style={{ width:1, height:24, background:'rgba(0,0,0,.1)' }} />
            <button className="btn" title="Zoom -" onClick={()=> setCamera(c => ({ ...c, scale: Math.max(.25, c.scale * .9) }))}>−</button>
            <button className="btn" title="Reset" onClick={()=> setCamera({ x:0, y:0, scale:1 })}>1:1</button>
            <button className="btn" title="Zoom +" onClick={()=> setCamera(c => ({ ...c, scale: Math.min(3, c.scale * 1.1) }))}>+</button>
          </div>
        );
      }

      function LayerPanel() {
        return (
          <div className="shadow rounded-2xl panel border" style={{ position:'fixed', top: 12, right: 12, zIndex: 50, width: 300, padding: 12 }}>
            <div style={{ display:'flex', alignItems:'center', justifyContent:'space-between', marginBottom: 8 }}>
              <div style={{ fontSize: 14, fontWeight: 700 }}>Layers</div>
              <button className="btn" onClick={addLayer}>+ New</button>
            </div>
            <div style={{ maxHeight: '60vh', overflow:'auto' }}>
              {layers.map(l => (
                <div key={l.id} className="border rounded-xl" style={{ display:'flex', alignItems:'center', gap: 8, padding: 8, marginBottom: 8, background: activeLayerId === l.id ? 'rgba(0,0,0,.05)' : '#fff' }}>
                  <input type="checkbox" checked={l.visible} onChange={()=> toggleLayerVisibility(l.id)} title="Show/Hide" />
                  <button className="btn" style={{ flex: 1, textAlign:'left', fontWeight: activeLayerId === l.id ? 700 : 500 }} onClick={()=> setActiveLayer(l.id)} title="Activate">{l.name}</button>
                  <button className="btn" onClick={()=> renameLayer(l)} title="Rename">✎</button>
                  <button className="btn" onClick={()=> deleteLayer(l)} title="Delete">🗑</button>
                </div>
              ))}
            </div>
            <div style={{ marginTop: 8, paddingTop: 8, borderTop: '1px solid rgba(0,0,0,.1)', fontSize: 12, color: 'rgba(0,0,0,.6)' }}>
              <div>• Drag background to pan · mouse wheel to zoom.</div>
              <div>• Drag notes to move (global position).</div>
              <div>• Use @ on card to reference into active layer.</div>
              <div>• Base color on owner; reference overrides color only.</div>
            </div>
          </div>
        );
      }

      function AppRoot() {
        return (
          <div style={{ position:'fixed', inset: 0 }}>
            <Toolbar />
            <LayerPanel />
            <div ref={canvasRef} className="gridbg" style={{ position:'absolute', inset: 0 }} onMouseDown={onBackgroundMouseDown}></div>
            {state.notes.map(n => <NoteCard key={n.id} note={n} />)}
          </div>
        );
      }

      ReactDOM.render(<AppRoot />, document.getElementById('root'));
    </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.error);
      });
    }
  </script>
</body>
</html>
